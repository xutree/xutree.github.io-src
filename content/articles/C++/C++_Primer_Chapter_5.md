Title: C++ Primer 第五章 语句
Category: C++
Date: 2018-10-09 12:06:33
Modified: 2018-10-09 12:06:33
Tags: C++

[TOC]

## 5.1 空语句

使用空语句时应该加上注释，从而令读这段代码的知道该语句是有意省略的。

## 5.2 悬垂 else

C++ 规定`else`与离它最近的尚未匹配的`if`匹配。

## 5.3 switch 语句

`switch`语句中的`case`标签必须是**整型常量表达式**或者**可以转换成整型常量表达式的类型**。

如果某个`case`标签匹配成功，将从该标签处开始往后顺序执行所有`case`分支，除非程序显示的中断了这一过程，否则直到`switch`结尾处才停下来。在大多说情况下，在下一个`case`标签之前应该有一条`break`语句用于中断。

标签不应该孤零零的出现，它后面必须跟上一条语句或者另一个`case`标签。如果`switch`结构以一个空的`default`标签作为结束，则该`default`标签后面必须跟上一条空语句或一个空块。

不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。

## 5.4 范围 for

在范围`for`语句中，预存了`end()`的值，一旦程序中添加（删除）元素，`end`函数的值就可能变得无效，所以不能通过范围`for`语句增加或删除容器的元素。

## 5.5 do while 语句

应该在括号包围起来的条件后面用一个分号表示语句结束。

## 5.6 跳转语句

### 5.6.1 break 语句

`break`语句负责终止离它最近的`while`、`do while`、`for`或`switch`语句，并从这些语句之后的第一条语句开始继续执行。

`break`语句只能出现在迭代语句或者`switch`语句内部（包括嵌套在此类循环里的语句或块的内部）。`break`语句的作用范围仅限于最近的循环或者`switch`。

### 5.6.2 continue 语句

`continu`e语句终止最近的循环中的当前迭代并立即开始下一次迭代。

`continue`语句只能出现在`for`、`while`和`do while`的循环的内部，或者嵌套在此类循环里的语句或块的内部。

和`break`语句类似的是，出现在嵌套循环中的`continue`语句也仅作用于离它最近的循环。

和`break`语句不同的是，只有当`switch`语句嵌套在迭代语句内部时，才能在`switch`里使用`continue`。

### 5.6.3 goto 语句

`goto`语句的作用是从`goto`语句无条件跳转到同一函数内的另一条语句。

`goto`语句和控制权转向的那条带标签的语句必须位于同一函数之内。

## 5.7 异常处理

### 5.7.1 throw 表达式

异常检测部分使用`throw`表达式来表示它遇到了无法处理的问题。我们说`throw`引发了异常，例如：

```
throw runtime_error("Data must refer to same ISBN");
```

### 5.7.2 try 语句块

异常处理部分使用`try`语句处理异常。`try`语句块以关键字`try`开始，并以一个或多个`catch`字句结束。`try`语句块中代码抛出的异常通常会被某个catch字句处理，这些字句称为异常处理代码。

```
try{
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
}
```

跟在`try`块之后的是一个或多个`catch`子句。`catch`子句包括三个部分：

- 关键字`catch`
- 括号内一个（可能未命名的）对象的声明（称作异常声明）
- 一个块

`try`语句块中 program-statements 组成程序的正常逻辑，像其他任何块一样，可以有包含声明在内的任意 C++ 语句。

`try`语句块内声明的变量在块外部无法访问，特别是在`catch子`句内也无法访问。

函数在寻找代码处理的过程中退出，如果最终没能找到任何匹配的`catch`子句，程序转到名为`terminate`的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。

### 5.7.3 标准异常

C++ 标准库定义了一组类，用于报告标准库函数遇到的问题，这些异常类也可以在用户别写的程序中使用，它们分别定义在4个头文件中：

#### 5.7.4 exception 头文件

定义了最通用的异常类`exception`。它只报告异常的发生，不提供任何异常信息

#### 5.7.5 stdexcept 头文件定义了几种常见的异常类

|异常类|解释|
|-----|---|
|exception|最常见的问题|
|runtime_error|只有在运行时才能检测出的问题|
|range_error|运行时错误：生成的结果超出了有意义的值域范围|
|overflow_error|运行时错误：计算上溢|
|underflow_error|运行时错误：计算下溢|
|logic_error|程序逻辑错误|
|domain_error|逻辑错误：参数对应的结果值不存在|
|invalid_argument|逻辑错误：无效参数|
|length_error|逻辑错误：试图创建一个超出该类型最大长度的对象|
|out_of_range|逻辑错误：使用一个超出有效范围的值|

#### 5.7.6 new 头文件

定义了`bad_alloc`异常类型

#### 5.7.7 type_info 头文件

定义了`bad_cast`异常类型

标准异常库只定义了几种运算，包括创建和拷贝异常类型的对象，以及为异常类型的对象赋值。我们只能以默认初始化的方式初始化`exception`、`bad_alloc`和`bad_cas`t对象，不允许为这些对象提供初始值。

其他异常类型的行为则刚好相反。应该使用`string`对象或者 C 风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。

异常类型只定义了一个名为`what`的成员函数，该函数没有任何参数，返回值是一个指向 C 风格字符串的`const char *`。该字符串的目的是提供关于异常的一些文本信息。

`what`函数返回的 C 风格字符串的内容与异常对象的类型有关。如果异常类型只有一个字符串初始值，则`what`返回该字符串。对于其他无初始值的异常类型来说，`what`返回的内容由编译器决定。
