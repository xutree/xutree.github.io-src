Title: Head first Java 笔记
Category: 读书笔记
Date: 2019-09-16 22:30:04
Modified: 2019-09-16 22:50:33
Tags: Java

[TOC]

### 1. 基本概念

- `Java` 源代码编译成字节码，在不同平台上通过 `JVM` 执行字节码
- `System.out.print` 输出在同一行，`System.out.println` 输出会换行

### 2. 类与对象

- 任何变量只要加上 `public`、`static` 和 `final`，基本上都会变成全局取用的常数
- 可以把文件打包成 **.jar**，在其中加入 **manifest** 文件告知哪个文件中带有 `main()` 函数
- 所有的 `Java` 程序都定义在类中
- 面向对象设计不需要改动之前已经测试好的程序代码
- 类是蓝图描述对象如何创建
- 对象本身已知道的事务称为**实例变量**，他代表对象的**状态**
- 对象可执行的动作称为方法，他代表类的**行为**
- `Java` 的程序在执行期是一组会相互交谈的对象

### 3. `primitive` 主数据类型和引用

- 对于任意一个 `Java` 虚拟机来说，所有的引用大小都一样，但不同的虚拟机之间可能会以不同的方式表示引用
- 数组是对象
- `primitive` 主数据类型的值是该值的字节表示
- 引用变量的额值代表位于堆之对象的存取方法

### 4. 方法操作实例变量

- 类所描述的是对象知道什么与执行什么
- `Java` 是值传递，应用对象的值类似于对象的地址
- 将实例变量标记为私有的，并提供公有的 `getter` 和 `setter` 来控制存取动作
- 实例变量永远有默认值，局部变量没有默认值
- 实例变量声明在类内而不是方法中
- 局部变量声明在方法中
- 使用 **==** 来比较两个 `primitive` 主数据类型，或者判断两个引用是否引用同一个对象
- 使用 `equals()` 来判断两个对象是否在意义上相等

### 5. 超强力方法

- `Java` 程序应该从高层的设计开始
- 伪码、测试码、真实码
- 伪码描述要做什么事情而不是如何做
- 实现之前应该先编写测试码
- 使用 `Interger.parseInt()` 来取得 `String` 的整数值

### 6. 认识 `Java` 的 `API`

- `ArrayList` 方法
    - `add(Object elem)`
    - `remove(int index)`
    - `remove(Object elem)`
    - `contains(Object elem)`
    - `isEmpty()`
    - `indexOf(Object elem)`
    - `size()`
    - `get(int index)`
- `ArrayList` 自动调整大小
- 一般数组在创建时就必须确定大小
- 存放对象给一般数组时必须指定位置，`ArrayList` 直接 `add`
- 一般数组使用特殊的语法 `[]`
- `ArrayList` 类似于 `C++` 中的模板类
- 在 `Java` 中，类被包装在包中
- 数组用 `length` 这个变量取得大小
- 类有完整的名称，都是由包的名称与类的名称所组成的。`ArrayList` 实际上叫做 `java.util.ArrayList`

### 7. 继承与多态

- is-a：是一个对象
- has-a：是一个实例变量
- 继承概念下的 is-a 是个单向的关系
- 在子类可以不用完全覆盖掉父类的功能，只是再加上额外的行为，可以用 `super` 关键字取用父类，且必须是第一条语句
- `public` 类型的成员（实例变量和方法）会被继承
- `private` 类型的成员（实例变量和方法）不会被继承
- 子类是父类 `extends` 来的
- 继承下来的方法可以被覆盖掉，但实例变量不能被覆盖掉
- 继承避免了重复的程序代码，定义出共同的协议
- 运用多态时，引用类型可以是实际对象类型的父类
- 参数和返回类型也可以多态
- 非公有的类只能被同一个包的类继承
- 使用 `final` 修饰的类不能被继承
- 拥有 `private` 构造函数的类不能被继承
- 覆盖的规则：参数必须要一样，返回类型必须要兼容；不能减低方法的存取权限

### 8. 接口和抽象类

- `abstract class Myclass extends Object {}`
- `public abstract void eat();`
- 含有抽象方法的类一定是抽象类
- 抽象的类可以带有抽象的和非抽象的方法
- 抽象方法没有内容，他的声明以分号结束，只是为了标记多态而存在，在继承树结构下的第一个具体类必须要实现所有的抽象方法
- `Java` 所有类都是从 `Object` 类继承而来
    - `equals(Object c)`
    - `getClass()`
    - `hashCode()`
    - `toString()`
- 任何从 `ArrayList<Object>` 取出的东西都会被当做 `Object` 类型的引用而不管他原来是什么
- 不管实际上所引用的对象是什么类型，只有在引用变量的类型就是带有某方法的类型时才能调用该方法
- `Father father = new Son()` 是**父类引用指向子类对象**而不是父类对象指向子类引用
- **子类的引用不能指向父类的对象**
- **当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法**
- 多态：继承、重写、父类引用指向子类对象
- `a instanceOf b` 判断 a 是不是 b 的对象
- 多重继承，致命方块 ---> 接口
- 接口的定义 `public interface Pet {...}`
- 接口的实现 `public class Dog extends Canine implements Pet {...}`
- 接口的方法默认是 `public` 和 `abstract` 的
- 不同继承树的类也可以实现相同的接口
- **如果想要定义出类扮演的角色，使用接口**
- `Java` 不允许多重继承
- 接口就好像 100\% 纯天然抽象类
- `class` 可以实现多个接口
- 实现接口的类必须实现他的所有方法

### 9. 构造器与垃圾收集器

- 对象的生存空间是堆（heap），方法调用及变量的生存空间是栈（stack）
- 非 `primitive` 的变量只是保存了对象的引用而已，如果局部变量是对象的引用，只有变量本身会放在栈上，对象在堆上
- 实例变量存在于对象所属的堆空间上
- 如果实例变量全是主数据类型，`Java` 会依据主数据类型的大小为该实例变量留下空间
- 如果实例变量是个对象，`Java` 会给变量的值留下空间，至于所指的对象是否在堆上，要看此实例变量有没有被赋值
- 唯一能够调用构造函数的方法就是新建一个类
- 构造函数没有返回值
- `Java` 可以有与类同名的函数而不会变成构造函数，只要其有返回值即可
- 最好要有不带参数的构造函数，让人可以选择使用默认值
- 编译器只会在你完全没有设定构造函数时才会调用
- 可以使用 `this` 从某个构造函数调用同一个类的另一个构造函数，` this()` 只能用在构造函数中，且必须是第一条语句，`super()` 和 `this` 不可兼得

### 10. 数字与静态

- 在 `Math` 这个类中所有的方法都不需要实例变量值，因为这些方法都是静态的，所以你无须实例，你会用到的只有他的类本身
- `Math` 的构造函数是私有的，你不能创建他的实例
- 如果类只有静态的方法，你可以将构造函数标记为 `private` 以避免被初始化
- 静态方法是属于类本身的
- `static` 关键字
- 静态的方法不能调用非静态的变量和非静态的方法
- 虽然可以用类的实例调用静态方法，但是尽量避免
- 静态变量被所有的实例共享
- 静态变量会在该类的任何静态方法执行之前就初始化
- 静态变量的默认值等于该变量类型的默认值
- 静态的 `final` 变量是常数
- 常数变量的名称应该都大写
- 静态初始化程序是一段在加载类时会执行的程序代码，它会在其他程序可以使用该类之前就执行，所以很适合放静态 `final` 变量的初始程序
- 静态 `final` 变量的初始化
    - 声明的时候
    ```
    public class Foo { public static final int FOO_X = 25;}
    ```
    - 在静态初始化程序中
    ```
    public class Bar {
        public static final double BAR_SIGN;

        static {
            BAR_SIGN = (double) Math.random();
        }
    }
    ```
- `Math` 的方法
    - `Math.random()`：0.0~1.0 之间的双精度浮点数
    - `Math.abs()`：有重载的版本，传入整数会返回整数，双精度会返回双精度
    - `Math.round()`：有重载的版本，根据传入是浮点还是双精度，四舍五入返回整型或长整型
    - `Math.min()`：有 `int`、`long`、`float` 和 `double` 重载的版本
    - `Math.max()`：有 `int`、`long`、`float` 和 `double` 重载的版本
