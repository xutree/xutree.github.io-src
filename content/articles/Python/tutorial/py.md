Title: Python 教程
Category: 教程
Date: 2019-04-01 18:59:57
Modified: 2019-04-01 18:59:57
Tags: Python

[TOC]

## 1. 开始之前

Python 提供了很多数据结构，也支持大型程序，远超 shell 脚本或批处理文件的功能。Python 还提供比 C 语言更多的错误检查，而且作为一种“超高级语言”，它有高级的内置数据类型，比如灵活的数组和字典。

Python 允许你划分程序模块，在其他的 Python 程序中重用。它内置了很多的标准模块，你可以在此基础上开发程序。

Python 是一种解释型语言，在程序开发阶段可以为你节省大量时间，因为不需要编译和链接。

## 2. Python 解释器

### 2.1 调用解释器

在 Python 可用的机器上，Python 解释器通常放在 **/usr/local/bin/python3.7**；把 **/usr/local/bin** 放到你 Unix shell 的搜索路径当中 , 这样键入命令：`python3.7` 就能运行了。

另一种启动解释器的方式是 `python -c command [arg] ...`，其中 `command` 要换成想执行的指令，就像命令行的 **-c** 选项。由于 Python 代码中经常会包含对终端来说比较特殊的字符，通常情况下都建议用**英文单引号**把 `command` 括起来。

有些 Python 模块也可以作为脚本使用。可以这样输入：`python -m module [arg] ...`，这会执行 module 的源文件，就跟你在命令行把路径写全了一样。

在运行脚本的时候，有时可能也会需要在运行后进入交互模式。这种时候在文件参数前，加上选项 **-i** 就可以了。

### 2.2 传入参数

如果可能的话，解释器会读取命令行参数，转化为字符串列表存入 `sys` 模块中的 `argv` 变量中。执行命令 `import sys` 你可以导入这个模块并访问这个列表。这个列表最少也会有一个元素。

如果没有给定输入参数，`sys.argv[0]` 就是个空字符串。

如果脚本名是标准输入，`sys.argv[0]` 就是 '-'。

使用 `-c command` 时，`sys.argv[0]` 就会是 '-c'。

如果使用选项 `-m module`，`sys.argv[0]` 就是包含目录的模块全名。

在 `-c command` 或 `-m module` 之后的选项不会被解释器处理，而会直接留在 `sys.argv` 中给命令或模块来处理。

### 2.3 解释器的运行环境

默认情况下，Python 源码文件以 UTF-8 编码方式处理。如果不使用默认编码，要声明文件所使用的编码，文件的**第一行**要写成特殊的注释。语法如下所示：

```
# -*- coding: encoding -*-
```

关于**第一行**规则的一种例外情况是，源码以 UNIX "shebang" 行开头。这种情况下，编码声明就要写在文件的第二行。例如：

```
#!/usr/bin/env python3
# -*- coding: cp1252 -*-
```

## 3. Python 的非正式介绍

### 3.1 数字

整数有 `int` 类型，有小数部分的有 `float` 类型。

除法运算 (/) 永远返回浮点数类型。

如果要得到一个整数结果（忽略小数部分）你可以使用 // 运算符。

如果要计算余数，可以使用 %。

在Python中，可以使用 ** 运算符来计算乘方。

Python 也内置对复数的支持，使用后缀 j 或者 J 就可以表示虚数部分。

在交互模式下，上一次打印出来的表达式被赋值给变量 \_。

### 3.2 字符串

字符串有多种形式，可以使用单引号（'……'），双引号（"……"）都可以获得同样的结果。反斜杠 \\ 可以用来转义。

在交互式解释器中，输出字符串是在引号中的，特殊字符是前置了反斜杠的。函数 `print()` 会产生更方便阅读的输出，就是不使用引号，也不转义特殊字符。

如果你不希望前置了 \\ 的字符转义成特殊字符，可以使用原始字符串方式，在引号前添加 **r** 即可。

字符串字面值可以跨行连续输入。一种方式是用三重引号："""...""" 或 '''...'''。字符串中的回车换行会自动包含到字符串中，如果不想包含，在行尾添加一个 \\ 即可。

字符串可以用 \+ 进行连接（粘到一起），也可以用 \* 进行重复。相邻的两个或多个 字符串字面值（引号引起来的字符）将会自动连接到一起，只能对两个字面值这样操作，变量或表达式不行。

字符串是可以被 索引（下标访问）的，第一个字符索引是 0。单个字符并没有特殊的类型，只是一个长度为一的字符串。索引也可以用负数，这种会从右边开始数。注意 -0 和 0 是一样的，所以负数索引从 -1 开始。

使用过大的索引会产生一个错误，但是，切片中的越界索引会被自动处理。

Python 中的字符串不能被修改，它们是 `immutable` 的。因此，向字符串的某个索引位置赋值会产生一个错误。

内建函数 `len()` 返回一个字符串的长度。

### 3.3 列表

列表，可以通过方括号括起、逗号分隔的一组值得到。一个列表可以包含不同类型的元素，但通常使用时各个元素类型相同。

列表也支持索引和切片。所有的切片操作都返回一个新列表，这个新列表包含所需要的元素。

列表同样支持拼接操作 \+。

列表是一个 `mutable` 类型，就是说，它自己的内容可以改变。

在列表结尾，通过 `append()` 方法 添加新元素。

内建函数 `len()` 返回一个列表的长度。

## 4. 其他流程控制工具

### 4.1 if 语句

```
>>> if x < 0:
...     x = 0
...     print('Negative changed to zero')
... elif x == 0:
...     print('Zero')
... elif x == 1:
...     print('Single')
... else:
...     print('More')
```

### 4.2 for 语句

```
>>> for w in words:
...     print(w, len(w))
```

如果在循环内需要修改序列中的值（比如重复某些选中的元素），推荐你先拷贝一份副本。对序列进行循环不代表制作了一个副本进行操作。


### 4.3 range() 函数

给定的终止数值并不在要生成的序列里；`range(10)` 会生成 10 个值，并且是以合法的索引生成一个长度为 10 的序列。`range` 也可以以另一个数字开头，或者以指定的幅度增加（甚至是负数；有时这也被叫做 '步进'）。

`range()` 所返回的对象在许多方面表现得像一个列表，但实际上却并不是。此对象会在你迭代它时基于所希望的序列返回连续的项，但它没有真正生成列表，这样就能节省空间。

我们说这样的对象是可迭代的，也就是说，适合作为函数和结构体的参数，这些函数和结构体期望在迭代结束之前可以从中获取连续的元素。我们已经看到 `for` 语句就是这样一个迭代器。函数 `list()` 是另外一个；它从可迭代对象中创建列表。

```
>>> list(range(5))
[0, 1, 2, 3, 4]
```

### 4.4 break 和 continue 语句，以及循环中的 else 子句

循环语句可能带有一个 `else` 子句；它会在循环遍历完列表 (使用 `for`) 或是在条件变为假 (使用 `while`) 的时候被执行，但是不会在循环被 `break` 语句终止时被执行。

### 4.5 pass 语句

`pass` 语句什么也不做。

### 4.6 定义函数

```
>>> def fib(n):    # write Fibonacci series up to n
...     """Print a Fibonacci series up to n."""
...     a, b = 0, 1
...     while a < n:
...         print(a, end=' ')
...         a, b = b, a+b
...     print()
...
```

函数体的第一个语句可以（可选的）是字符串文字；这个字符串文字是函数的文档字符串或 `docstring`。

### 4.7 函数定义的更多形式

#### 4.7.1 参数默认值

默认值是在定义过程中在函数定义处计算的，所以

```
i = 5

def f(arg=i):
    print(arg)

i = 6
f()
```

会打印 5。

重要警告： 默认值只会执行一次。这条规则在默认值为可变对象（列表、字典以及大多数类实例）时很重要。比如，下面的函数会存储在后续调用中传递给它的参数：

```
def f(a, L=[]):
    L.append(a)
    return L

print(f(1))
print(f(2))
print(f(3))
```

这将打印出

```
[1]
[1, 2]
[1, 2, 3]
```

#### 4.7.2 关键字参数

在函数调用中，关键字参数必须跟随在位置参数的后面。

传递的所有关键字参数必须与函数接受的其中一个参数匹配，它们的顺序并不重要。

不能对同一个参数多次赋值。

#### 4.7.3 任意的参数列表

最不常用的选项是可以使用任意数量的参数调用函数。这些参数会被包含在一个元组里（参见 元组和序列 ）。在可变数量的参数之前，可能会出现零个或多个普通参数。

#### 4.7.4 解包参数列表

使用 \* 运算符编写函数调用以从列表或元组中解包参数。

```
>>> list(range(3, 6))            # normal call with separate arguments
[3, 4, 5]
>>> args = [3, 6]
>>> list(range(*args))            # call with arguments unpacked from a list
[3, 4, 5]
```

#### 4.7.5 Lambda 表达式

`Lambda` 函数可以在需要函数对象的任何地方使用。它们在语法上限于单个表达式。

从语义上来说，它们只是正常函数定义的语法糖。与嵌套函数定义一样，`lambda` 函数可以引用包含范围的变量。

返回两个参数的和：`lambda a, b: a+b`

#### 4.7.6 文档字符串

以下是有关文档字符串的内容和格式的一些约定。

第一行应该是对象目的的简要概述。这一行应以大写字母开头，以句点结尾。

如果文档字符串中有更多行，则第二行应为空白，从而在视觉上将摘要与其余描述分开。

Python 解析器不会从 Python 中删除多行字符串文字的缩进，因此处理文档的工具必须在需要时删除缩进。这是使用以下约定完成的。文档字符串第一行之后的第一个非空行确定整个文档字符串的缩进量。（我们不能使用第一行，因为它通常与字符串的开头引号相邻，因此它的缩进在字符串文字中不明显。）然后从字符串的所有行的开头剥离与该缩进 "等效" 的空格。缩进的行不应该出现，但是如果它们出现，则应该剥离它们的所有前导空格。应在扩展标签后测试空白的等效性（通常为 8 个空格）。

#### 4.7.7 函数标注

函数标注是关于用户自定义函数中使用的类型的完全可选元数据信息。

函数标注以字典的形式存放在函数的 `__annotations__` 属性中，并且不会影响函数的任何其他部分。

形参标注的定义方式是在形参名称后加上冒号，后面跟一个表达式，该表达式会被求值为标注的值。

返回值标注的定义方式是加上一个组合符号 ->，后面跟一个表达式，该标注位于形参列表和表示 def 语句结束的冒号之间。

```
>>> def f(ham: str, eggs: str = 'eggs') -> str:
...     print("Annotations:", f.__annotations__)
...     print("Arguments:", ham, eggs)
...     return ham + ' and ' + eggs
...
>>> f('spam')
Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}
Arguments: spam eggs
'spam and eggs'
```

### 4.8 编码风格

- 使用 4 个空格缩进，不要使用制表符
- 换行，使一行不超过 79 个字符
- 使用空行分隔函数和类，以及函数内的较大的代码块
- 如果可能，把注释放到单独的一行
- 使用文档字符串
- 在运算符前后和逗号后使用空格，但不能直接在括号内使用： `a = f(1, 2) + g(3, 4)`
- 类和函数命名的一致性；规范是使用 CamelCase 命名类，lower_case_with_underscores 命名函数和方法。始终使用 self 作为第一个方法参数的名称
- 如果你的代码旨在用于国际环境，请不要使用花哨的编码
- 不要在标识符中使用非 ASCII 字符
